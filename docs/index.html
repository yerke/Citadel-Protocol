<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Software development kit for creating high performance, extremely-secure, and post-quantum network applications. Supports p2p (NAT traversal + WebRTC) and standard client/server architectures for messaging and streaming. The underlying asynchronous runtime is Tokio."><meta name="keywords" content="rust, rustlang, rust-lang, citadel_sdk"><title>citadel_sdk - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../citadel_sdk/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../citadel_sdk/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate citadel_sdk</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">citadel_sdk</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/citadel_sdk/lib.rs.html#1-150">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Software development kit for creating high performance, extremely-secure, and post-quantum network applications. Supports p2p (NAT traversal + WebRTC) and standard client/server architectures for
messaging and streaming. The underlying asynchronous runtime is <a href="https://tokio.rs">Tokio</a>.</p>
<p>The Network protocol, SDK, and user libraries use 100% safe rust</p>
<p>All peer-discovery and NAT traversal are built-in to the protocol, with the central server acting as a broker and authenticator. The central server is used for TURN-like routing when direct p2p NAT traversal fails between two nodes.</p>
<p>Authentication to a central node is required before making peer-to-peer connections. There is both device-dependent auth as well as credentialed authentication backed by the argon2id hashing algorithm.</p>
<p>Client/Peer information is by default synchronized to the local filesystem. If the <em>redis</em> and/or <em>sql</em> feature is enabled, a redis or SQL (MySQL, PostgreSQL, SQLite) server or cluster can be used instead.</p>
<p>When messaging is used, perfect forward secrecy (PFS) is an optional mode on a per-session basis. Best-effort mode (BEM) is also available if the security of PFS is not needed, and instead, high throughput
in messaging is required.</p>
<p>Client-to-server connections can use TCP, TLS (default), or QUIC protocols for the underlying communication. Cryptographers recommend the use of hybrid protocols, and as such, TLS is the default to
ensure implementations of post-quantum networks are at least as secure as traditional methods. Valid certificates can be specified when constructing the application, otherwise, self-signed certificates are used for the underlying protocol.</p>
<p>Peer-to-peer connections only use QUIC. In order to establish a direct peer-to-peer connection, UDP NAT-traversal is required, and as such, the use of QUIC complements this requirement since QUIC uses UDP for ordered, reliable transport.</p>
<p>Streaming is also available in this crate. When the use of webrtc is desired for an application, the <em>webrtc</em> feature can be enabled to allow interoperability between the <a href="prelude/struct.UdpChannel.html"><code>UdpChannel</code></a> and the <a href="https://webrtc.rs">WebRTC.rs</a> ecosystem.</p>
<h2 id="feature-flags"><a href="#feature-flags">Feature Flags</a></h2>
<ul>
<li><code>single-threaded</code>: Uses a single-threaded !Send executor for the inner protocol</li>
<li><code>multi-threaded</code>: Uses a multi-threaded Send executor for the inner protocol</li>
<li><code>redis</code>: Enables the use of Redis for the backend</li>
<li><code>sql</code>: Enables the use of sql for the backend</li>
<li><code>webrtc</code>: enables <em>limited</em> interoperability with webrtc via the <a href="prelude/struct.UdpChannel.html"><code>UdpChannel</code></a> (see: <a href="prelude/struct.UdpChannel.html#method.into_webrtc_compat">UdpChannel::into_webrtc_compat</a>)</li>
</ul>
<h2 id="post-quantum-key-encapsulation-mechanisms"><a href="#post-quantum-key-encapsulation-mechanisms">Post-quantum key encapsulation mechanisms</a></h2>
<p>The user may also select a KEM family before a session to either a central server or peer begins (see: <a href="prelude/struct.SessionSecuritySettingsBuilder.html">SessionSecuritySettingsBuilder</a>). Each KEM has variants that alter the degree of security</p>
<ul>
<li>Kyber (default)</li>
</ul>
<h2 id="encryption-algorithms"><a href="#encryption-algorithms">Encryption Algorithms</a></h2>
<p>The user may also select a symmetric encryption algorithm before a session starts (see: <a href="prelude/struct.SessionSecuritySettingsBuilder.html">SessionSecuritySettingsBuilder</a>)</p>
<ul>
<li>AES-256-GCM-SIV</li>
<li>XChacha20Poly-1305</li>
<li>Kyber “scramcryption” (see below for explanation)</li>
</ul>
<p>Whereas AES-GCM and ChaCha are only quantum resistant (as opposed to post-quantum), a novel method of encryption may be used that
combines the post-quantum asymmetric encryption algorithm Kyber coupled with AES. When Kyber “scramcryption” is used, several modifications to the protocol outlined in the whitepaper
is applied. The first modification is the use of Falcon-1024 to sign each message to ensure non-repudiation. The second modification is more complex. Ciphertext is first encrypted by AES-GCM, then, randomly shifted using modular arithmetic
in 32-byte blocks using a 32-byte long quasi one-time pad (OTP). The OTP is unique for each ciphertext, and, is appended at the end of the ciphertext in encrypted form (using Kyber1024 encryption). Even if the attacker uses Grover’s algorithm to
discover the AES key, the attacker would also have to break the lattice-based Kyber cryptography in order to properly order
the ciphertext before using the AES key. Since every 32 bytes of input into the Kyber encryption scheme produces over a 1KB output ciphertext, and, each scramble dictionary is 32 bytes long,
the size of each packet is increased at a constant value, helping keep packet sizes minimal and security very high.</p>
<h2 id="executor-architecture-the-netkernel"><a href="#executor-architecture-the-netkernel">Executor Architecture: The <code>NetKernel</code></a></h2>
<p>Any node in the network may act as <strong>both</strong> a server and a client/peer (except for when <a href="prelude/enum.NodeType.html#variant.Peer"><code>NodeType::Peer</code></a> or the default node type is specified). Since multiple parallel connections may exist, handling events is necessary. When the lower-level protocol produces events,
they are sent to the <a href="prelude/trait.NetKernel.html"><code>NetKernel</code></a>. The <a href="prelude/trait.NetKernel.html"><code>NetKernel</code></a> is where your application logic must be written.</p>
<h3 id="initialization-stage-the-kernelexecutor-and-the-noderemote"><a href="#initialization-stage-the-kernelexecutor-and-the-noderemote">Initialization Stage: The <code>KernelExecutor</code> and the <code>NodeRemote</code></a></h3>
<p>When the node is built and awaited (as seen in the examples below), the node creates a <a href="prelude/struct.NodeRemote.html"><code>NodeRemote</code></a> which is used to communicate between the <a href="prelude/trait.NetKernel.html"><code>NetKernel</code></a> and the lower level networking protocol. Then, the <a href="prelude/struct.KernelExecutor.html"><code>KernelExecutor</code></a> passes the remote to <a href="prelude/trait.NetKernel.html#tymethod.load_remote"><code>NetKernel::load_remote</code></a> (which uses a mutable reference to
the kernel itself to allow mutation of the inner data, effectively ensuring that the remote may be stored without need of atomics, as well as any other config). Thereafter, the <a href="prelude/struct.KernelExecutor.html"><code>KernelExecutor</code></a> calls <a href="prelude/trait.NetKernel.html#tymethod.on_start"><code>NetKernel::on_start</code></a> (uses an <code>&amp;self</code> reference) where any first asynchronous calls using the remote itself may be made.</p>
<h3 id="passive-stage"><a href="#passive-stage">Passive Stage</a></h3>
<p>As the protocol generates events, the developer may choose to add program logic to react to the events. When an event is sent from the protocol to the <a href="prelude/struct.KernelExecutor.html"><code>KernelExecutor</code></a>, the <a href="prelude/struct.KernelExecutor.html"><code>KernelExecutor</code></a> executes <a href="prelude/trait.NetKernel.html#tymethod.on_node_event_received"><code>NetKernel::on_node_event_received</code></a>, passing the new event. Importantly,
every call to <a href="prelude/trait.NetKernel.html#tymethod.on_node_event_received"><code>NetKernel::on_node_event_received</code></a> is executed <em>concurrently</em> (<strong>not</strong> to be confused with <em>parallel</em>), allowing the developer to react to each event separately without having to await completion before handling the next event. If an error is returned from <a href="prelude/trait.NetKernel.html#tymethod.on_node_event_received"><code>NetKernel::on_node_event_received</code></a>, then the <a href="prelude/struct.KernelExecutor.html"><code>KernelExecutor</code></a> will attempt
a graceful shutdown of the protocol and any running sessions. Errors returned from <a href="prelude/trait.NetKernel.html#tymethod.on_node_event_received"><code>NetKernel::on_node_event_received</code></a> are propagated to the initial awaited call site on the node.</p>
<p>Important note: Since <a href="prelude/trait.NetKernel.html#tymethod.on_node_event_received"><code>NetKernel::on_node_event_received</code></a> takes self by reference and is executed concurrently, <a href="prelude/trait.NetKernel.html"><code>NetKernel</code></a> requires that <code>Self: Sync</code> since by definition, if <code>&amp;T: Send</code>, then <code>T: Sync</code></p>
<h3 id="shutdown-stage"><a href="#shutdown-stage">Shutdown stage</a></h3>
<p>Whether through an error, or, a call to <a href="prelude/struct.NodeRemote.html#method.shutdown"><code>NodeRemote::shutdown</code></a>, the <a href="prelude/struct.KernelExecutor.html"><code>KernelExecutor</code></a> will call <a href="prelude/trait.NetKernel.html#tymethod.on_stop"><code>NetKernel::on_stop</code></a> (which is passed an &amp;mut). During and after the execution of <a href="prelude/trait.NetKernel.html#tymethod.on_stop"><code>NetKernel::on_stop</code></a>, no more calls to <a href="prelude/trait.NetKernel.html#tymethod.on_node_event_received"><code>NetKernel::on_node_event_received</code></a> will occur. Any errors returned from <a href="prelude/trait.NetKernel.html#tymethod.on_stop"><code>NetKernel::on_stop</code></a> will be propagated
to the initial awaited call site on the node. Execution is complete, returning the initial kernel on success</p>
<h2 id="examples"><a href="#examples">Examples</a></h2><h3 id="server"><a href="#server">Server</a></h3>
<p>When building either a client/peer or server node, a <a href="prelude/trait.NetKernel.html"><code>NetKernel</code></a> is expected. In the case below, an EmptyKernel is used that does no additional processing of inbound connections:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>citadel_sdk::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::net::SocketAddr;
<span class="kw">use </span>std::str::FromStr;
<span class="kw">use </span>citadel_sdk::prefabs::server::empty_kernel::EmptyKernel;

<span class="comment">// this server will listen on 127.0.0.1:25021, and will use the built-in defaults. When calling &#39;build&#39;, a NetKernel is specified
</span><span class="kw">let </span>server = NodeBuilder::default()
.with_node_type(NodeType::Server(SocketAddr::from_str(<span class="string">&quot;127.0.0.1:25021&quot;</span>).unwrap()))
.build(EmptyKernel::default())<span class="question-mark">?</span>;

<span class="comment">// await the server to execute
</span><span class="kw">let </span>result = server.<span class="kw">await</span>;</code></pre></div>
<h3 id="clientpeer"><a href="#clientpeer">Client/Peer</a></h3>
<p>This client will connect to the server above. It will first register (if the account is not yet registered), and thereafter, connect to the server, calling the provided future to handle the received channel</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>citadel_sdk::prefabs::client::single_connection::SingleClientServerConnectionKernel;
<span class="kw">use </span>std::net::SocketAddr;
<span class="kw">use </span>std::str::FromStr;
<span class="kw">use </span>futures::StreamExt;
<span class="kw">use </span>citadel_sdk::prelude::NodeBuilder;

<span class="kw">let </span>client_kernel = SingleClientServerConnectionKernel::new_register_defaults(<span class="string">&quot;John Doe&quot;</span>, <span class="string">&quot;john.doe&quot;</span>, <span class="string">&quot;password&quot;</span>, SocketAddr::from_str(<span class="string">&quot;127.0.0.1:25021&quot;</span>).unwrap(), |connect_success, remote| <span class="kw">async move </span>{
    <span class="comment">// handle program logic here
    </span><span class="kw">let </span>(sink, <span class="kw-2">mut </span>stream) = connect_success.channel.split();
    <span class="kw">while let </span><span class="prelude-val">Some</span>(message) = stream.next().<span class="kw">await </span>{
        <span class="comment">// message received in the form of a SecBuffer (memory-protected)
    </span>}
});

<span class="kw">let </span>client = NodeBuilder::default().build(client_kernel).unwrap();
<span class="kw">let </span>result = client.<span class="kw">await</span>;</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="backend_kv_store/index.html" title="citadel_sdk::backend_kv_store mod">backend_kv_store</a></div><div class="item-right docblock-short">Store data to the backend using this library</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="prefabs/index.html" title="citadel_sdk::prefabs mod">prefabs</a></div><div class="item-right docblock-short">A list of prefabricated kernels designed for common use cases. If a greater degree of control is required for an application, a custom implementation of <a href="prelude/trait.NetKernel.html">NetKernel</a> is desirable</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="prelude/index.html" title="citadel_sdk::prelude mod">prelude</a></div><div class="item-right docblock-short">Convenience import for building applications</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="remote_ext/index.html" title="citadel_sdk::remote_ext mod">remote_ext</a></div><div class="item-right docblock-short">Extension implementations endowed upon the <a href="prelude/struct.NodeRemote.html">NodeRemote</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="responses/index.html" title="citadel_sdk::responses mod">responses</a></div><div class="item-right docblock-short">For easy construction of replies to common message types
A list of helpers making the response phase simple and intuitive</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="citadel_sdk" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>